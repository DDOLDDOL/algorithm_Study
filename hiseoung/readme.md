# 알고리즘 개념 및 문제에 대한 생각 정리

## DP(다이내믹프로그래밍)

* 재귀에 대한 최적화
* 중복되는 부분 문제에 대한 결과를 저장하고 이를 재사용하는 형태로 시간복잡도를 줄일 수 있음
* 배열 차원은 재귀 구현 시 움직이는 매개변수의 수
* 어떻게 매개 변수를 부분문제와 연결할지 생각하기

### 하향식 접근(Top Down)

* 재귀를 사용
* 핵심 문제에서 시작 -> 부분 문제로 나눔 -> 이에 대한 결과를 메모이제이션


### 상향식 접근(Bottom up)

* 부분문제를 먼저 해결 -> 배열에 결과 저장


#### 생각

* 파이썬이라서 그런지 모르겠지만 재귀를 사용하는 하향식 접근법을 적용하면 시간복잡도와 공간복잡도가 굉장히 많이 늘어난다. 따라서 파이썬으로 DP문제를 풀려고 할때는 상향식접근법을 먼저 고려하고 이로 해결할 수 업다면 하향식접근법으로 이어가는게 좋을 것 같다.

## 정렬

* 파이썬에서 리스트를 이용한 sort()의 시간복잡도는 O(nlogn)

### 문제 : 수 정렬3(10989)
* 카운팅 정렬 이용(O(n))
* 시간복잡도가 선형이지만 주어지는 수의 범위만큼 배열을 할당해야하기 때문에 메모리낭비가 심함
* 수의 범위가 적은 경우에 사용
* 그 외의 일반적인 정렬 상황에서는 O(nlogn)의 시간복잡도를 갖는 알고리즘들(퀵정렬, 힙정렬 등)을 이용하는 것이 권장됨
* 파이썬에서는 리스트에 내장되어있는 sort()를 사용하거나 sorted()를 사용하면됨

### 문제 : 전화번호 목록(5052)
* 문자열 길이 순으로 정렬 후 처음 인덱스부터 값부터 나머지 값들과 비교하는 방식을 써봤지만 25%에서 시간초과(O(n^2))
* 알고리즘 분류가 트라이로 되어 있어서 구글링 후 적용 -> 통과(O(m))
* 파이썬으로 통과한 코드들을 살펴보니 파이썬 내장함수 중에 startswith()이라는 함수가 있어서 이를 이용하면 통과할 수 있음
* 트라이 알고리즘은 대부분의 문자열 탐색에서 이용된다고 하니 기억하고 있는게 좋을듯
* 파이썬 문자열 함수
** find('x') -> x문자를 찾은 위치(인덱스) 반환
** startswith('xy') -> xy로 시작한다면 True 아니면 False반환
** endswith('xy') -> xy로 끝난다면 True 아니면 False반환
